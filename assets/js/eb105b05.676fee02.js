"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[6415],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return f}});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=l(n),f=a,h=d["".concat(c,".").concat(f)]||d[f]||u[f]||o;return n?r.createElement(h,s(s({ref:t},p),{},{components:n})):r.createElement(h,s({ref:t},p))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},8325:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return i},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return d}});var r=n(7462),a=n(3366),o=(n(7294),n(3905)),s=["components"],i={sidebar_position:17},c="What is ref?",l={unversionedId:"Core React/ref-prop",id:"Core React/ref-prop",isDocsHomePage:!1,title:"What is ref?",description:"What is the use of refs?",source:"@site/docs/Core React/ref-prop.md",sourceDirName:"Core React",slug:"/Core React/ref-prop",permalink:"/react-mastery/docs/Core React/ref-prop",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/Core React/ref-prop.md",tags:[],version:"current",sidebarPosition:17,frontMatter:{sidebar_position:17},sidebar:"tutorialSidebar",previous:{title:"What is key?",permalink:"/react-mastery/docs/Core React/key-prop"},next:{title:"What is Virtual DOM?",permalink:"/react-mastery/docs/Core React/virtual-dom"}},p=[{value:"What is the use of refs?",id:"what-is-the-use-of-refs",children:[],level:2},{value:"How to create refs?",id:"how-to-create-refs",children:[],level:2},{value:"What are forward refs?",id:"what-are-forward-refs",children:[],level:2},{value:"Which is the preferred option within callback refs and findDOMNode()?",id:"which-is-the-preferred-option-within-callback-refs-and-finddomnode",children:[],level:2},{value:"Why are String Refs legacy?",id:"why-are-string-refs-legacy",children:[],level:2}],u={toc:p};function d(e){var t=e.components,n=(0,a.Z)(e,s);return(0,o.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"what-is-ref"},"What is ref?"),(0,o.kt)("h2",{id:"what-is-the-use-of-refs"},"What is the use of refs?"),(0,o.kt)("p",null,"The ref is used to return a reference to the element.\nThey should be avoided in most cases, however,\nthey can be useful when you need direct access to\nthe DOM element or an instance of a component."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"It stands for refrence."),(0,o.kt)("li",{parentName:"ul"},"It is used to refer the element in the components."),(0,o.kt)("li",{parentName:"ul"},"I will be added to the ",(0,o.kt)("strong",{parentName:"li"},"actual DOM")," of the component.")),(0,o.kt)("h2",{id:"how-to-create-refs"},"How to create refs?"),(0,o.kt)("p",null,"There are two approaches"),(0,o.kt)("p",null,"This is a recently added approach. Refs are created\nusing ",(0,o.kt)("inlineCode",{parentName:"p"},"React.createRef()")," method and attached to React\nelements via the ref attribute. In order to use refs\nthroughout the component, just assign the ref to the\ninstance property within the constructor."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"class MyComponent extends React.Component {\n  constructor(props) {\n    super(props);\n    this.myRef = React.createRef();\n  }\n  render() {\n    return <div ref={this.myRef} />;\n  }\n}\n")),(0,o.kt)("p",null,"You can also use ",(0,o.kt)("inlineCode",{parentName:"p"},"useRef")," callbacks approach regardless of\nReact version. For example, the search bar\ncomponent's input element accessed as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'class SearchBar extends Component {\n  constructor(props) {\n    super(props);\n    this.txtSearch = null;\n    this.state = { term: "" };\n    this.setInputSearchRef = (e) => {\n      this.txtSearch = e;\n    };\n  }\n  onInputChange(event) {\n    this.setState({ term: this.txtSearch.value });\n  }\n  render() {\n    return (\n      <input\n        value={this.state.term}\n        onChange={this.onInputChange.bind(this)}\n        ref={this.setInputSearchRef}\n      />\n    );\n  }\n}\n')),(0,o.kt)("p",null,"You can also use refs in function components using\nclosures. Note: You can also use inline ref callbacks\neven though it is not a recommended approach."),(0,o.kt)("h2",{id:"what-are-forward-refs"},"What are forward refs?"),(0,o.kt)("p",null,"Ref forwarding is a feature that lets some components\ntake a ref they receive, and pass it further down to a\nchild."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'const ButtonElement = React.forwardRef((props, ref) => (\n  <button ref={ref} className="CustomButton">\n    {props.children}\n  </button>\n));\n\n// Create ref to the DOM button:\nconst ref = React.createRef();\n<ButtonElement ref={ref}>{"Forward Ref"}</ButtonElement>;\n')),(0,o.kt)("h2",{id:"which-is-the-preferred-option-within-callback-refs-and-finddomnode"},"Which is the preferred option within callback refs and findDOMNode()?"),(0,o.kt)("p",null,"It is preferred to use callback refs over ",(0,o.kt)("inlineCode",{parentName:"p"},"findDOMNode()"),"\nAPI. Because ",(0,o.kt)("inlineCode",{parentName:"p"},"findDOMNode()")," prevents certain\nimprovements in React in the future."),(0,o.kt)("p",null,"The legacy approach of using ",(0,o.kt)("strong",{parentName:"p"},"findDOMNode"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"class MyComponent extends Component {\n  componentDidMount() {\n    findDOMNode(this).scrollIntoView();\n  }\n  render() {\n    return <div />;\n  }\n}\n")),(0,o.kt)("p",null,"The recommended approach is:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},"class MyComponent extends Component {\n  constructor(props) {\n    super(props);\n    this.node = createRef();\n  }\n  componentDidMount() {\n    this.node.current.scrollIntoView();\n  }\n  render() {\n    return <div ref={this.node} />;\n  }\n}\n")),(0,o.kt)("h2",{id:"why-are-string-refs-legacy"},"Why are String Refs legacy?"),(0,o.kt)("p",null,"If you worked with React before, you might be\nfamiliar with an older API where the ref attribute is a\nstring, like ",(0,o.kt)("inlineCode",{parentName:"p"},"ref={'textInput'}"),", and the DOM node\nis accessed as ",(0,o.kt)("inlineCode",{parentName:"p"},"this.refs.textInput"),". We advise\n",(0,o.kt)("strong",{parentName:"p"},"against")," it because string refs have below issues, and\nare considered legacy. String refs were removed in\nReact v16."),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"They force React to keep track of the currently\nexecuting component. This is problematic\nbecause it makes the react module stateful,\nand thus causes weird errors when the react\nmodule is duplicated in the bundle."),(0,o.kt)("li",{parentName:"ol"},"They are not composable \u2014 if a library puts a\nref on the passed child, the user can't put\nanother ref on it. Callback refs are perfectly\ncomposable."),(0,o.kt)("li",{parentName:"ol"},"They don't work with static analysis like Flow.\nFlow can't guess the magic that framework\ndoes to make the string ref appear on\n",(0,o.kt)("inlineCode",{parentName:"li"},"this.refs"),", as well as its type (which could be\ndifferent). Callback refs are friendlier to static\nanalysis.")),(0,o.kt)("p",null,'It doesn\'t work as most people would expect with the\n"render callback" pattern (e.g. )\nclass MyComponent extends Componen'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-jsx"},'class MyComponent extends Component {\n  renderRow = (index) => {\n    // This won\'t work. Ref will get attached to DataTable rather than MyComponent:\n    return <input ref={"input-" + index} />;\n    // This would work though! Callback refs are awesome.\n    return <input ref={(input) => (this["input-" + index] = input)} />;\n  };\n  render() {\n    return <DataTable data={this.props.data} renderRow={this.renderRow} />;\n  }\n}\n')))}d.isMDXComponent=!0}}]);